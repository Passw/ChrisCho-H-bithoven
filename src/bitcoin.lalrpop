use std::str::FromStr;
use super::ast::*;

grammar;

pub UTXO: UTXO = {
    "UTXO" "(" <stack:StackParamList> ")" <script: Script> => {
        UTXO {
            input_stack: stack,
            output_script: script,
        }
    }
}

pub Script: Vec<Statement> = {
    <statement:Statement*> => statement,
}

// Bitcoin script sig(witness) stack
pub StackParamList: Vec<StackParam> = {
    <first:StackParam> <more:MoreStackParams*> => {
        let mut stack = more;
        stack.insert(0, first);
        stack
    },
    => vec![], // epsilon production
};
pub StackParam: StackParam = <i:Identifier> <c:Colon> <t:Type> => {
    StackParam {
        identifier: i,
        ty: t,
    }
};
pub MoreStackParams: StackParam = <c:Comma> <s:StackParam> => s;

pub Statement: Statement = {
    <d:VarDeclarationStatement> => <>,
    <e:ExprStatement> => <>,
    <i:IfStatement> => <>,
    <a:AfterStatement> => <>,
    <o:OlderStatement> => <>,
    <v:VerifyStatement> => <>,
}

// No epsilon for Initalizer, don't neet to have Initializer rule
VarDeclarationStatement: Statement = "let" <i:Identifier> "=" <e:Expr> ";" => {
    Statement::VarDeclarationStatement {
        identifier: i,
        expr: e,
    }
};
// Need to have expression statement to avoid conflict of shift-reduce
ExprStatement: Statement = <e:Expr> ";" => {
    Statement::ExprStatement(e)
};
// If statement follows semantics of bitcoin OP_(NOT)IF, OP_ELSE...
// reference1: https://bitcoin.stackexchange.com/questions/103844/inner-working-of-op-if-and-op-else
// reference2: https://bitcoin.stackexchange.com/questions/90868/does-bitcoin-script-support-nested-ifs-op-if-or-op-notif-inside-one-another
IfStatement: Statement = {
    "if" <c:ConditionExpr> <b:BlockStatement> => {
        Statement::IfStatement {
            condition_expr: c,
            if_block: b,
            else_block: None,
        }
    },
    "if" <c:ConditionExpr> <b1:BlockStatement> "else" <b2:BlockStatement> => {
        Statement::IfStatement {
            condition_expr: c,
            if_block: b1,
            else_block: Some(b2),
        }
    },
};
BlockStatement: Vec<Statement> = "{" <s:Script> "}" => s;
// Bitcoin specific language sytax. OP_CLTV. inspired by miniscript syntax.
AfterStatement: Statement = "after" <u:UnsignedInteger> <s:SemiColon> => {
    Statement::AfterStatement(u as u32)
};
// Bitcoin specific language sytax. OP_CSV. inspired by miniscript syntax.
OlderStatement: Statement = "older" <u:UnsignedInteger> <s:SemiColon> => {
    Statement::OlderStatement(u as u32)
};
// Bitcoin specific language sytax. verify signature against public key
VerifyStatement: Statement = "verify" <e:Expr> <s:SemiColon> => {
    Statement::VerifyStatement(e)
};
/*
// Bitcoin specific language sytax. push data to stack. can be replaced [].push() later
PushDataStatement: String = "push" <Literal> ";" => (<>).into();
*/


pub Expr: Expression = {
    <Identifier> => Expression::Variable(<>),
    <BooleanLiteral>,
    <StringLiteral>,
    <NumberLiteral>,
    <CheckSigExpr>,
    <Sha256Expr>,
    <Ripemd160Expr>,
    //<MathExpr>,
};

// Bitcoin specific language sytax. verify signature against public key
CheckSigExpr: Expression = "checksig" <e:Expr> => Expression::CheckSigExpr(Box::new(e));
// Bitcoin specific language sytax. OP_SHA256. inspired by miniscript syntax.
Sha256Expr: Expression = "sha256" <e:Expr> => Expression::Sha256Expr(Box::new(e));
// Bitcoin specific language sytax. OP_RIPEMD160. inspired by miniscript syntax.
Ripemd160Expr: Expression = "ripemd160" <e:Expr> => Expression::Ripemd160Expr(Box::new(e));

// Support both OP_IF and OP_NOTIF
ConditionExpr: ConditionExpression = {
    <n:Not> "(" <c:CompareExpr> ")" => {
        ConditionExpression {
            negate: true,
            compare_expr: c
        }
    },
    "(" <c:CompareExpr> ")" => {
        ConditionExpression {
            negate: false,
            compare_expr: c
        }
    }, // to support js like syntax(while redundant)
    <c:CompareExpr> => {
        ConditionExpression {
            negate: false,
            compare_expr: c
        }
    },
}


// By separating CmpExpr, you can ensure that boolean operators (&&, ||) only operate on boolean values, 
// and arithmetic operators (+, -, *, /) only operate on numeric values.
CompareExpr: CompareExpression = {
    <l:Expr> <c:BinaryCompareOp> <r:Expr> => {
        CompareExpression {
            lhs: l,
            op: c,
            rhs: r,
        }
    }
}

MathExpr: Expression = {
    <l:Expr> <c:BinaryMathOp> <r:Expr> => {
        Expression::MathExpression {
            lhs: Box::new(l),
            op: c,
            rhs: Box::new(r),
        }
    }
};

// Below are Token
// Terminal sequence in the context of lexer(tokenizer)

// Binary Ops(Minus can be both Unary and Binary)
BinaryMathOp: BinaryMathOp = {
    "+" => BinaryMathOp::Add,
    "-" => BinaryMathOp::Sub,
}

BinaryCompareOp: BinaryCompareOp = {
    "==" => BinaryCompareOp::Equal,
    "!=" => BinaryCompareOp::NotEqual,
    ">"  => BinaryCompareOp::Greater,
    ">=" => BinaryCompareOp::GreaterOrEqual,
    "<"  => BinaryCompareOp::Less,
    "<=" => BinaryCompareOp::LessOrEqual,
};
Assign: String           = "="  => "=".to_string();
And: String              = "&&" => "&&".to_string();
Or: String               = "||" => "||".to_string();
// UnaryOps
Not: String              = "!"  => "!".to_string();
Negation: String         = "~"  => "~".to_string();

// Puctuation
Comma: String = "," => ",".to_string();
Colon: String = ":" => ":".to_string();
SemiColon: String = ";" => ";".to_string();
OpenParen: String = "(" => "(".to_string();
CloseParen: String = ")" => ")".to_string();
OpenBrace: String = "{" => "{".to_string();
CloseBrace: String = "}" => "}".to_string();
OpenBracket: String = "[" => "[".to_string();
CloseBracket: String = "]" => "]".to_string();

// Below are terminals(more precisely, output terminals)
// Must be leaf node of AST

Type: Type = {
    "bool" => Type::Boolean,
    "string" => Type::String,
    "number" => Type::Number,
    "signature" => Type::Signature,
}

Identifier: Identifier = <v:r"[a-zA-Z_][a-zA-Z0-9_]*"> => Identifier(v.to_string());

StringLiteral: Expression = <l:r#""(\\\\|\\"|[^"\\])*""#> => Expression::StringLiteral(l[1..l.len()-1].into());

BooleanLiteral: Expression = {
    "true" => Expression::BooleanLiteral(true),
    "false" => Expression::BooleanLiteral(false),
}

NumberLiteral: Expression = {
     <p:UnsignedInteger> => Expression::NumberLiteral(p),
    // Unary minus at the Integer level(Precedence of fixed strings exists)
    // LALRPOP prefers to find the longest match first. 
    // After that, if there are two matches of equal length, it prefers the fixed string
    "-" <p:UnsignedInteger> => {
       // Number is 32 bit sign magnitude int, except when used as locktime.
       // To determine whether locktime or not is beyond context-free grammar.
       // Can be addressed when context analysis done
       if p > i32::MAX as i64 {
           panic!("overflow")
       }
       Expression::NumberLiteral(-p)
    }
};

UnsignedInteger: i64 = <s:r"[0-9]+"> => {
    let integer = i64::from_str(s).unwrap();
    // Number is 32 bit sign magnitude int, except when used as locktime.
    // To determine whether locktime or not is beyond context-free grammar.
    // Can be addressed when context analysis done
    if integer <= i32::MIN as i64 || integer > u32::MAX as i64 {
        panic!("overflow")
    } else {
        integer
    }
};

pub Comment: () = { 
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
}

// When there's Ambiguities between regular expressions,
// Use a match declaration, which lets you control the precedence between regular expressions.
// A match declaration lets you explicitly give the precedence between terminals
/*
match {
    r"[0-9]+"
} else {
    r"\w+",
    _
}
*/